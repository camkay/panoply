---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# panoply <img src="tools/panoply_hex.png" width = 167 align="right"/>

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/camkay/panoply.svg?branch=master)](https://travis-ci.org/camkay/panoply)
[![Codecov test coverage](https://codecov.io/gh/camkay/panoply/branch/master/graph/badge.svg)](https://codecov.io/gh/camkay/panoply?branch=master)
[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

A panoply of miscellaneous functions: `column_find`, `column_alpha`, `column_combine`, `scuttle`, `spround`, `perble`, `lenique`, `pasterisk`, and  `paste_paren`. `scuttle` was created in collaboration with [AshLynnMiller](https://github.com/AshLynnMiller).

## Installation

The development version of `panoply` can be installed from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("camkay/panoply")
```

## Descriptions and Examples

```{r setup, include = FALSE}
# load panoply
library(panoply)

# suppress scientific notation
options(scipen = 999)

# create example data
data_example <- data.frame(scale1_item1 = c(6, 1, 3, 4, 5, 9, 9),
                           scale1_item2 = c(7, 2, 4, 5, 4, 8, 9),
                           scale1_item3 = c(8, 1, 5, 4, 4, 9, 8),
                           scale2_item1 = c(9, 9, 9, 8, 4, 2, 2),
                           scale2_item2 = c(7, 8, 7, 9, 5, 1, 2))

# create example numeric vector
num_example  <- c(5, 1, 0, .5, .1, .05, .01, .005, .001, .0005)

# create example character vector
char_example  <- c("cat", "cat", "dog", "cat", "dog", "giraffe")
```

### column_find

`column_find` is a function for quickly identifying columns of a data frame that match a `pattern` specified through a string. The default behaviour is to return a logical vector, indicating the columns that match the `pattern`. Using the `return` argument, users can request that a vector of column numbers ("numeric") or column names ("character") be returned. Users can also request that a data frame with only those columns be returned ("data.frame"). `column_find` can interpret [regular expressions](https://en.wikipedia.org/wiki/Regular_expression).

```{r column_find_example}
# look at example data
data_example

# return a logical vector of the columns that match the pattern
column_find(pattern = "scale1", return = "logical", data = data_example)

# return a numeric vector of the columns that match the pattern
column_find(pattern = "scale1", return = "numeric", data = data_example)

# return a character vector of the columns that match the pattern
column_find(pattern = "scale1", return = "character", data = data_example)

# return a data frame of the columns that match the pattern
column_find(pattern = "scale1", return = "data.frame", data = data_example)

# return a logical vector using a regular expression
column_find(pattern = "2$", return = "logical", data = data_example)
```

### column_alpha

`column_alpha` estimates Cronbach's Alpha–an indicator of internal consistency–using only columns that have names that match a `pattern`. The analysis relies on `psych::alpha`. If the `full` argument is `TRUE`, the full results of the reliability analysis produced by the `psych` package is returned. If `FALSE`, only the raw alpha value is returned. In both cases, a message is generated informing the users what columns were used to calculate the alpha value. 

```{r column_alpha_example}
# look at example data
data_example

# return the full reliability analysis for scale 1
column_alpha(pattern = "scale1", full = TRUE, data = data_example)

# return only the raw Cronbach's Alpha for scale 1
column_alpha(pattern = "scale1", full = FALSE, data = data_example)

```

### column_combine

`column_combine` creates a composite column using only columns in a data frame that have names that match a `pattern`. The argument `fun` specifies specifies what function should be used to create the composite column. Averaging is the default. 

```{r column_combine_example}
# look at example data
data_example

# return a vector of rowwise means for scale 1
column_combine(pattern = "scale1", fun = mean, data = data_example)

# return a vector of rowwise sums for scale 1
column_combine(pattern = "scale1", fun = sum, data = data_example)

```

### scuttle

`scuttle` turns a continuous (i.e., numeric) variable into a categorical (i.e., character or factor) variable. Using the `split` argument, users can specify whether they want a (1) quantile-split, (2) split at 1, 2, or 3 standard deviations above or below the mean, (3) split at 1, 2, or 3 standard errors above or below the mean. Users can specify whether the output should be a factor or a character using the `as.factor` argument.

```{r scuttle_example}
# look at example data
data_example

# split scale1_item1 using a quantile-split method and return a factor
scuttle(column = data_example$scale1_item1, split = "quantile", as.factor = TRUE)

# split scale1_item1 using a 1sd-split method and return a character vector
scuttle(column = data_example$scale1_item1, split = "sd1", as.factor = FALSE)
```

### spround

`spround` rounds a number or a vector of numbers (using `round`) and specifies knitted decimal places (using `sprintf`) all in one step. Users can specify whether leading zeroes should be retained or not using `leading0`.

```{r spround_example}
# look at example numeric vector
num_example

# round num_example to three decimal places and retain leading zeroes
spround(x = num_example, digits = 3, leading0 = TRUE)

# round num_example to three decimal places and drop leading zeroes
spround(x = num_example, digits = 3, leading0 = FALSE)
```

### perble

`perble` extends `table` by including proportions and percentages. By default the results are put into [tidy format](https://en.wikipedia.org/wiki/Tidy_data). Results will be returned as a numeric matrix if the `tidy` argument is set to `FALSE`.

```{r perble_example}
# look at example character vector
char_example

# produce the counts, proportions, and percentages and present the results in tidy format
perble(x = char_example, tidy = TRUE)

# produce the counts, proportions, and percentages and present the results as a numeric vector
perble(x = char_example, tidy = FALSE)
```

### lenique

`lenique` is a very simple wrapper that calculates the length of unique values in a vector in one step. It is identical to running `length(unique(x))`.

```{r lenique_example}
# look at the example character vector
char_example

# calculate the length of unique values in char_example
lenique(x = char_example)
```

### pasterisk

`pasterisk` takes a scalar or atomic vector of, for example, p-values and returns a scalar or atomic vector of asterisks corresponding to different significance levels. The argument `thresholds` can be used to set the cut-off valuess for the different values. Any number of thresholds can be set. By default, an asterisk (i.e., "*") is used as the `sig_symbol`, but any single character vector can be used. 

```{r pasterisk_example}
# look at the example numeric vector
num_example

# create a vector of asterisks using the default thresholds
pasterisk(p_vals = num_example, thresholds = c(0.05, 0.01, 0.001), sig_symbol = "*")

# create a vector of octothorps/hashtags/pound using the default thresholds
pasterisk(p_vals = num_example, thresholds = c(0.05, 0.01, 0.001), sig_symbol = "#")

# create a vector of asterisks using custom thresholds
pasterisk(p_vals = num_example, thresholds = c(0.10, 0.5), sig_symbol = "*")

```

### paste_paren

`paste_paren` combines two numbers (e.g., 10.12 and 2.22) by wrapping the latter in parentheses (e.g., 10.12(2.22)). This function was made to streamline the creation of tables that include cells as formatted "mean(sd)".

```{r paste_paren_example}
# combine two numbers
paste_paren(10.12, 2.22)
```
